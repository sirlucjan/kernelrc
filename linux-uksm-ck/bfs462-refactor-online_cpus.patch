From ae4591a2a622ae1ff176ca880409c9ecaff1d5a5 Mon Sep 17 00:00:00 2001
From: Alfred Chen <cchalpha@gmail.com>
Date: Wed, 15 Oct 2014 10:29:54 +0800
Subject: [PATCH] bfs: [1/3] Refactor online_cpus() checking in try_preempt().

---
 kernel/sched/bfs.c | 23 +----------------------
 1 file changed, 1 insertion(+), 22 deletions(-)

diff --git a/kernel/sched/bfs.c b/kernel/sched/bfs.c
index 43545ac..636d5f6 100644
--- a/kernel/sched/bfs.c
+++ b/kernel/sched/bfs.c
@@ -1308,25 +1308,6 @@ can_preempt(struct task_struct *p, int prio, u64 deadline)
 }
 
 #ifdef CONFIG_SMP
-#define cpu_online_map		(*(cpumask_t *)cpu_online_mask)
-#ifdef CONFIG_HOTPLUG_CPU
-/*
- * Check to see if there is a task that is affined only to offline CPUs but
- * still wants runtime. This happens to kernel threads during suspend/halt and
- * disabling of CPUs.
- */
-static inline bool online_cpus(struct task_struct *p)
-{
-	return (likely(cpus_intersects(cpu_online_map, p->cpus_allowed)));
-}
-#else /* CONFIG_HOTPLUG_CPU */
-/* All available CPUs are always online without hotplug. */
-static inline bool online_cpus(struct task_struct *p)
-{
-	return true;
-}
-#endif
-
 /*
  * Check to see if p can run on cpu, and if not, whether there are any online
  * CPUs it can run on instead.
@@ -1362,9 +1343,7 @@ static void try_preempt(struct task_struct *p, struct rq *this_rq)
 	if (p->policy == SCHED_IDLEPRIO)
 		return;
 
-	if (likely(online_cpus(p)))
-		cpus_and(tmp, cpu_online_map, p->cpus_allowed);
-	else
+	if (unlikely(!cpumask_and(&tmp, cpu_online_mask, &p->cpus_allowed)))
 		return;
 
 	highest_prio = latest_deadline = 0;
-- 
2.1.1
 
